---
globs: *.py
description: Python coding standards for OpenVPN Manager project
---

## ðŸ‘¨â€ðŸ’» Developer Role Requirements

**Act as Principal Developer/Chief Architect:**
- Complete system analysis before implementation
- Optimize for low-resource server environments
- No inline comments or Persian text in code
- English docstrings only above methods/classes
- Execute exactly what's requested, nothing more

# ðŸš€ Development Protocol - MANDATORY BEFORE ANY CODING

## ðŸ” 1. COMPLETE ANALYSIS BEFORE ANY CODE
**Never start coding without full understanding:**
- Carefully analyze EXPLICIT and IMPLICIT goals of requests
- Break down tasks into two clear lists:
  a) Clear set of objectives/expected outcomes
  b) Precise, step-by-step implementation plan

## âš ï¸ 2. DO NOT CODE IF TASK IS UNCLEAR OR UNSAFE
**Generate NO code until:**
- Request is fully understood
- Solution is architecturally sound
- Implementation is technically feasible

**If request is ambiguous, incomplete, or technically risky, clearly state so.**
**If request is not technically feasible, respond: "This request is not technically feasible as described."**

## ðŸ§  3. CODE QUALITY & ARCHITECTURE REQUIREMENTS
**Generated code MUST be:**
âœ… Complete and functional
âœ… Clean and readable
âœ… Well-structured and modular
âœ… Production-ready and maintainable

**Follow SOLID principles, clean architecture, and separation of concerns.**

**NEVER write:**
âŒ Partial or placeholder code
âŒ Repetitive or unclean logic
âŒ Quick hacks or spaghetti code

**Comments must be:**
âœ… Clear and in English only
âœ… Placed at class/method level when needed
âŒ Never excessive or in other languages

## ðŸ’¡ 4. EFFICIENCY & RESOURCE OPTIMIZATION
**Always prioritize simple, efficient, and lightweight solutions.**
**Avoid:**
âŒ Unnecessary complexity or over-abstraction
âŒ Heavy dependencies or bloated frameworks
âŒ Memory-intensive operations

**Code must perform well on resource-constrained servers:**
- Target: 1 GB RAM or less
- Optimize for minimal CPU and memory usage
- Avoid excessive async operations or background processes

## ðŸ”’ 5. STRICT SCOPE ADHERENCE
**Implement ONLY what was explicitly requested.**
**If you identify potentially useful additions not in scope, ask: "This exceeds your current request - should I include this?"**
**Never exceed defined requirements without explicit approval.**

## âš ï¸ 6. PROACTIVE RISK ASSESSMENT
**Before implementing, identify potential issues:**
- Performance bottlenecks
- Security vulnerabilities
- Compatibility problems
- Architectural conflicts

**If risks exist, pause and state: "This approach may cause [specific risks]. Should I proceed or explore alternatives?"**

## ðŸ§© 7. ARCHITECTURAL INTEGRATION
**Always analyze existing codebase structure before modifications.**
**Ensure new code integrates seamlessly with current architecture.**
**Prioritize:**
âœ… System scalability and performance
âœ… Code reusability and modularity
âœ… Long-term maintainability
âœ… Clear separation of concerns

## ðŸ§­ 8. SENIOR ARCHITECT MINDSET
**Think beyond immediate implementation:**
- Consider edge cases and error scenarios
- Plan for future extensibility
- Ensure robust error handling
- Design for real-world production use

**You are a technical decision maker, not just a code generator.**
**Question unclear requirements and suggest improvements when appropriate.**

## ðŸ“Œ 9. QUALITY ASSURANCE STANDARDS
**Never assume project structure - request clarification if needed.**
**Avoid speculative implementations ("this probably works").**
**Every solution must be:**
âœ… Deliberately designed
âœ… Technically justified
âœ… Production-ready
âœ… Resource-efficient

# Python Coding Standards

## ðŸ Code Quality Requirements

### Type Safety
- **ALWAYS** use type hints for function parameters and return values
- Import types from `typing` module: `Optional`, `List`, `Dict`, `Any`
- Use custom types from [core/types.py](mdc:core/types.py): `Username`, `Password`, `ConfigData`

### Error Handling
- Use custom exceptions from [core/exceptions.py](mdc:core/exceptions.py)
- **NEVER** use bare `except:` - always specify exception types
- Log errors with context using the established logging pattern
- For CLI operations, provide user-friendly error messages
- For API operations, return consistent JSON error responses with HTTP status codes

### Database Operations
- **ALWAYS** use parameterized queries (SQL injection protection)
- Use transactions for multi-step operations (see [scripts/on_disconnect.py](mdc:scripts/on_disconnect.py))
- Handle database errors gracefully with rollback

### Security Requirements
- Use `bcrypt` for password hashing (see [service/user_service.py](mdc:service/user_service.py))
- Validate file permissions when creating system files
- Check root privileges for system operations
- Sanitize all user inputs

### Performance Guidelines
- Use incremental traffic recording in monitor service
- Implement connection pooling for high-traffic scenarios
- Close resources properly (sockets, file handles)
- Use efficient parsing for OpenVPN status output

## ðŸ“ Documentation Standards
- Include docstrings for all public methods
- Document complex business logic
- Use clear variable names that explain purpose

## ðŸŒ API Development Patterns

### Flask Route Structure
- **Blueprint organization**: Separate blueprints for logical grouping (users, quota, system)
- **Authentication decorator**: Always use `@AuthMiddleware.require_auth` for protected endpoints
- **Service layer delegation**: Routes should only validate input and delegate to service layer
- **Consistent error responses**: Use standard JSON error format with appropriate HTTP codes

### Factory Pattern for Dependencies
```python
def get_user_service() -> UserService:
    """Factory function - ALWAYS use this pattern for dependency injection."""
    db = Database()
    user_repo = UserRepository(db)
    login_manager = LoginUserManager()
    openvpn_manager = OpenVPNManager()
    return UserService(user_repo, openvpn_manager, login_manager)
```

### API Response Standards
```python
# Success response
return jsonify({'message': 'Operation successful', 'data': result}), 200

# Error response
return jsonify({'error': 'Error type', 'message': 'User-friendly description'}), status_code
```

### Input Validation
- **Request data validation**: Always validate JSON request data before processing
- **Type checking**: Use isinstance() for runtime type validation
- **Service layer validation**: Delegate complex validation to service layer
- **Error propagation**: Let service layer exceptions bubble up to route error handlers

## ðŸ”’ API Security Patterns

### Authentication
- **API key verification**: Use constant-time comparison with `hmac.compare_digest()`
- **Environment variables**: Store sensitive configuration in environment variables
- **Header validation**: Require `X-API-Key` header for all protected endpoints

### Input Sanitization
- **User input cleaning**: Strip whitespace and validate format before processing
- **SQL injection prevention**: Always use parameterized queries through repository layer
- **Path traversal protection**: Validate file paths and prevent directory traversal

## âš¡ Performance Optimization

### Flask Application
- **Static file serving**: Optimize caching headers for different asset types
- **Request processing**: Minimize memory allocation in request handlers
- **Database connections**: Efficient connection handling through service layer
- **Response compression**: Enable gzip compression for text responses